<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <style>
      .container {
        height: 400px;
        overflow: scroll;
        width: 400px;
        padding: 50px;
      }
      li {
        padding: 10px;
        height: 40px;
        background-color: bisque;
        position: relative;
      }
      li::after {
        content: '';
        width: 400px;
        height: 1px;
        background-color: gray;
        position: absolute;
        left: 0;
        top: -8px;
      }
    </style>
  </head>
  <body>
    <div id="root" class="container" style="background-color: bisque"></div>
    <script>
      let scrollPosition = 0, // 记录scrollTop
        list = new Array(8).fill({ title: 'list数据title', value: 'list数据value', pageIndex: 0 }), // 获取到的数据
        isStartGetData = false; // 是否开始请求数据
      let pageLimit = 2; //  需维护数组的长度
      let pageMap = [1]; // 对应数组长度的页码表
      let pageIndex = 1; // 分页中请求的页面
      let pageSize = 8; // 自定义  每页的大小
      let listItem = { title: 'list数据title', value: 'list数据value', pageIndex: 1 }; // 模拟假数据
      let SCROLL_DOM = document.querySelector('.container');
      console.log('--', list);
      list.forEach(listItem => {
        render(SCROLL_DOM, listItem);
      });
      SCROLL_DOM.addEventListener('scroll', function () {
        // 如果为true则代表向上滚动，false代表向下滚动
        let flagToDirection = this.scrollTop - scrollPosition > 0;
        // 记录当前的滚动位置
        scrollPosition = this.scrollTop;
        const LIMIT_BOTTOM = 100;
        // 向下滚动 记录滚动位置距离底部的位置
        let scrollBottom = this.scrollHeight - (this.scrollTop + this.clientHeight) < LIMIT_BOTTOM;
        // 向下滚动 如果已达到指定位置则触发
        if (scrollBottom) {
          // 将滚动行为告诉组件
          handScroll(flagToDirection, SCROLL_DOM, this.scrollHeight / 2);
        }
        // 向上滚动
        if (!flagToDirection && this.scrollTop < LIMIT_BOTTOM) {
          // 将滚动行为告诉组件
          handScroll(flagToDirection, SCROLL_DOM, this.scrollHeight / 2);
        }
      });
      // direction 为true代表向下滚动 为false代表向上滚动
      function handScroll(direction, el, middlePosition) {
        console.log(direction ? '向下' : '向上');
        if (direction) {
          if (pageMap.length >= pageLimit) {
            // 当长度相等的时候， 绝对不能超出长度  则有进必有出
            // 删除 pageMap 列表的第一个元素
            pageMap.shift();
            // TODO 也要移除dom，再vue 框架里面，只需操作数据就好
            // 对应删除list中一页的数据量
            list.splice(0, pageSize);
          }
          // 请求下一页的数据
          getData(direction, el, middlePosition);
          // 同步记录页码
        } else {
          // // 如果在向上滚动时，如果还没有到达第一页则继续加载。 如果已到达则停止加载
          if (pageMap[0] > 1) {
            // 请求上一页的数据
            getData(direction, el, middlePosition);
          } else return false;
        }
      }
      // 请求数据 direction向上向下滚动  middlePosition 滚动列表的中间位置
      function getData(direction, el, middlePosition) {
        // 向下
        if (!isStartGetData && direction) {
          isStartGetData = true;
          setTimeout(() => {
            isStartGetData = false;
            const items = [1, 2, 3, 4, 5, 6, 7, 8].map((item, index) => {
              return {
                title: `数据title_${pageIndex}_下`,
                value: 'list数据value',
                index: `${index}_${pageIndex}`,
                pageIndex: pageIndex
              };
            });
            list = [...list, ...items];
            ++pageIndex;
            pageMap.push(pageIndex);
            list.forEach(listItem => {
              render(el, listItem);
            });
            // 回滚到中间位置
            el.scrollTop = middlePosition;
            console.log('1分钟后，请求数据:list 向下：', list, middlePosition);
          }, 1000);
        }
        // 向上
        if (!isStartGetData && !direction) {
          isStartGetData = true;
          // 向上滚动，取出pageMap中第一个元素值减1
          pageIndex = pageMap[0] - 1;
          // 同步设置分页
          // ①先删除最后一个元素
          pageMap.pop();
          // ②将新元素添加在头部
          pageMap = [pageIndex, ...pageMap];
          // ①删除list中最后一页的数据
          // TODO 也要移除dom，再vue 框架里面，只需操作数据就好
          list.splice(-pageSize, pageSize);
          // ②将新数据添加在头部位置
          setTimeout(() => {
            isStartGetData = false;
            listItem.pageIndex = pageIndex;
            // 回滚到中间位置
            el.scrollTop = middlePosition;
            const items = [1, 2, 3, 4, 5, 6, 7, 8].map((item, index) => {
              return {
                title: `数据title_${pageIndex}_下`,
                value: 'list数据value',
                index: `${index}_${pageIndex}`,
                pageIndex: pageIndex
              };
            });
            list = [...items, ...list];
          }, 1000);
        }
      }

      function render(el, listItem) {
        const node = document.createElement('li'); //创建一个li节点
        const asd = document.createTextNode(`${listItem.title}_${listItem.value}`); //定义创建文本节点
        node.appendChild(asd); //把文本节点追加到li节点
        el.appendChild(node);
      }
    </script>
  </body>
</html>
